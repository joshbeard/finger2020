#!/usr/bin/env python3
"""
finger2020 - A tiny, secure finger daemon for UNIX systems

## About

This finger service uses files to load contact information, and will not extract
any sensitive information directly from the host system. So relax! It's intended
to be used by a sysop to broadcast server news and/or personal contact
information over the internet.

## Operation

This program is designed to be hosted behind a systemd socket or a comparable
``inetd``-like service. The program will read a one-line query from stdin. The
response string will be written to stdout, and all error/logging messages will
be directed to stderr and should be setup to route to an appropriate system log
manager.

## Query Support

Only the user list and user status queries are supported. Queries with
ambiguous user names will be rejected. Queries with hostnames will be rejected.
The verbose flag (``/W``) is accepted but will be ignored.

## Usage

```bash
# Query user list
echo -e "\r\n" | finger2020

# Query user information
echo -e "username\r\n" | finger2020
```

## Configuration

FINGER_NAME
    A string that will represent the user's finger name. This can be any
    arbitrary value and does not need to correspond to a real user on the
    system.

FINGER_CONTACT
    This file replaces the section of the query response that contains
    information that finger would typically generate. Common values to include
    in this section include login name, real name, phone number, office,
    address, and recent system activity.

FINGER_PROJECT
    This file typically contains a multi-line "profile page" with additional
    information about the user. The information documented in this file does not
    frequently change.

FINGER_PLAN

    This file typically contains a brief description of what the user is
    currently working on. This file is intended to be updated frequently and
    there are no restrictions on what type of information the user can include.

FINGER_INFO_LABELS

    Set to "true" or "false" to toggle showing the 'Project:' and 'Plan:' labels
    in the response.

Additional profiles can be configured by suffixing an underscore and label to
the standard environment variables. The suffix should be consistent for all variables for
a profile configuration. For example, substitute 'FOO' for a unique label:

    FINGER_NAME_FOO
    FINGER_PROJECT_FOO
    FINGER_PLAN_FOO
    FINGER_INFO_LABELS_FOO

A `FINGER_HIDE_FOO` variable is available for additional user profiles to toggle
displaying them in the user list query, which defaults to *false* (the user
*will* be displayed). Set this to "true" (case-insensitive) to prevent the user
profile from displaying in the query list. Any other value will display it.
"""
import os
import re
import sys

__author__ = "Michael Lazar"
__copyright__ = "(c) 2020 Michael Lazar"
__license__ = "The MIT License (MIT)"
__title__ = "finger2020"
__version__ = "1.0.0"

if sys.version_info[:2] < (3, 6):
    raise RuntimeError("Unsupported python version, required 3.6+")

HOME = os.path.expanduser("~")

FINGER_NAME = os.getenv("FINGER_NAME", "anonymous")
FINGER_CONTACT = os.getenv("FINGER_CONTACT", os.path.join(HOME, ".contact"))
FINGER_PLAN = os.getenv("FINGER_PLAN", os.path.join(HOME, ".plan"))
FINGER_PROJECT = os.getenv("FINGER_PROJECT", os.path.join(HOME, ".project"))
FINGER_INFO_LABELS = os.getenv("FINGER_INFO_LABELS", "true")

# Query specification:
#   {Q1}    ::= [{W}|{W}{S}{U}]{C}
#   {Q2}    ::= [{W}{S}][{U}]{H}{C}
#   {U}     ::= username
#   {H}     ::= @hostname | @hostname{H}
#   {W}     ::= /W
#   {S}     ::= <SP> | <SP>{S}
#   {C}     ::= <CRLF>
#
# Note: I suspect the definition for {Q1} is incomplete because the examples
#   show querying for a {U} user without the {W} token. My interpretation of
#   the intended implementation is [ {W} | {U} | {W}{S}{U} ] {C}.
# Note: The links browser appears to break spec and send "/W \r\n".
tokens = {
    "U": "(?P<username>\\w+)",
    "H": "(?P<hostname>@[\\w@.]+)",
    "W": "(/W)",  # Verbose mode, this flag is ignored
    "S": "( +)",
    "C": "(\r?\n)",  # Break spec and make the carriage return optional
}
q1_list_re = re.compile("({W}{S}?)?{C}".format(**tokens))
q1_search_re = re.compile("({W}{S})?{U}{C}".format(**tokens))
q2_re = re.compile("({W}{S})?{U}?{H}{C}".format(**tokens))


def read_file(filename):
    if filename:
        try:
            with open(filename) as fp:
                # Normalize file line endings to <CR><LF>
                text = "\r\n".join(line.rstrip() for line in fp.readlines())
        except OSError:
            sys.stderr.write(f"Unable to open file: {filename!r}\n")
            text = ""
    else:
        text = ""
    return text


def get_profiles(hidden=True):
    profiles = {}
    for var, value in os.environ.items():
        if var.startswith("FINGER_NAME_"):
            var_suffix = var.replace('FINGER_NAME_', '')
            hide = os.environ.get(f'FINGER_HIDE_{var_suffix}', "false")

            # Non-default is a string from env
            if hide.lower() == "true" and not hidden:
                continue
            else:
                profiles[value] = var_suffix
        elif var == "FINGER_NAME":
            # The default profile
            profiles[value] = None
        else:
            continue
    return profiles


def render_user_info(var_suffix):
    # If no varsuffix is set, use the defaults
    if var_suffix == None:
        contact = read_file(FINGER_CONTACT)
        project = read_file(FINGER_PROJECT)
        plan = read_file(FINGER_PLAN).strip()
        labels = FINGER_INFO_LABELS
    else:
        contact = read_file(os.environ.get(f"FINGER_CONTACT_{var_suffix}", False))
        project = read_file(os.environ.get(f"FINGER_PROJECT_{var_suffix}", False))
        plan = read_file(os.environ.get(f"FINGER_PLAN_{var_suffix}", False)).strip()
        labels = os.environ.get(f"FINGER_INFO_LABELS_{var_suffix}", "true")

    # Not actually a boolean since we read it from the environment
    if labels.lower() == "true":
        return "\r\n".join([contact, f"Project:", project, "", f"Plan: {plan}"])
    else:
        return "\r\n".join([contact, project, plan])


def handle(query):
    profiles = get_profiles()
    # We don't need no stinkin' := walrus operator!
    match = q2_re.fullmatch(query)
    if match:
        return "Finger forwarding service denied"

    match = q1_search_re.fullmatch(query)
    if match:
        user = match.group("username")
        if match.group("username") in profiles:
            return render_user_info(profiles[user])
        else:
            return "Finger user not found"

    match = q1_list_re.fullmatch(query)
    if match:
        users = ', '.join(get_profiles(hidden=False))
        return f"Users on this server: {users}"

    return "Finger invalid query"


def main():
    query = sys.stdin.readline(1024)
    sys.stderr.write(f"Received query: {query!r}\n")
    response = handle(query)
    sys.stdout.write(response)
    sys.stdout.write("\r\n")


if __name__ == "__main__":
    main()
